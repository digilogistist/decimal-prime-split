PHP Prime Number Production and Factoring Tools
Brad Taylor
Oct 8 2021


This is a collection of prime-related tools that can be used to factor and determine
large prime numbers up to a 63-bit positive integer.  The tools can build and maintain
a list of primes in the 32-bit unsigned integer domain that is stored in an external
binary file, as well as offer fast index-to-value conversions and also value-to-index.

Because prime numbering applications are not a one-size-fits-all thing, this suite of
tools provides alternate methods to generate the same function.  Some functions are
more lightweight on resources than others and can have tradeoffs like poor speed due
to this.  For example, determining the prime 9223372036854775783 takes prime() like
64 seconds to compute but Prime->Test() does it in about 9 seconds by using a preloaded 
prime table that stays in RAM.



+---------+
| Sources |
+---------+


To be a good programmer and understand how prime number production works, research
is strongly recommended.


https://www.dcode.fr/prime-factors-decomposition
This resource allows you to check for very large primes and factor them really fast.


https://en.wikipedia.org/wiki/List_of_prime_numbers
A list of the first 1000 primes.  An easy way to check if your prime number generator
is working at all.


https://onlinenumbertools.com/calculate-prime-numbers
This tool will generate a list of primes starting at a specified value.  I used this
one to verify the last 1024 primes of the PRIMES.BIN file, though it did take the
website about 10 minutes to punch that out.  Not bad!


https://primes.utm.edu/howmany.html
This resource reveals the relationship played between a large range of base-10 prime
composite domains and the amount of primes constitutung those respective domains.  
Useful for understanding memory allocation relationships.


https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
The Sieve of Eratosthenes is a technique used to generate a list of primes that is
more efficient than using a 2-dimensional brute force linear not-modulus detection
algorithm.  The tradeoff is the complexity and memory required to implement a system.



+-----------+
| The Files |
+-----------+


README.TXT	This file.


INDEX.PHP	Ccntains the main HTML page form input boxes, dropdowns and
		instructions on use.  Uses $_POST to securely communicate
		parameters to SPLIT.PHP, which removes them from the URL line.


SPLIT.PHP	Contains a program that is invoked by index.php when the user
		submits a form to run a test.  This program extracts the parameters
		from the form and implements the unit test for the decimal prime
		split function based on them.


FACTOR.PHP	Contains the most generic and lightweight prime factoring tools
		available, with some minor optimizations implemented for
		even-number factoring.  Suitable for general-purpose, non
		time-critical applications.


QFACTOR.PHP	Is a self-contained prime number factory, that progressively
		renders out a prime list to a file "PRIMES.BIN" as needed for
		factoring, as well as a list of corresponding modulus values
		"MODULO.BIN" required for successive prime rendering.  It is
		implemented with a hybrid Sieve of Eratosthenes algorithm that
		also maintains a list of modulus counters corresponding to each
		prime as the list expands.

		Factoring performance time is improved over factor() for large
		positive integers by at least 3x.  Can also render out a full list
		of 32-bit primes in 17 minutes, and then it never needs to render
		out a single prime again.

		By default qFactor() uses a minimal amount of RAM to factor.  However
		when rendering primes it requires a $bitmap_size to be specified,
		which corresponds to a Sieve domain slice.  Larger slices yeild
		faster prime rendering, but also use more RAM.  The default
		setting is suitable for casual progressive factoring, and is
		immaterial once a full prime list is completed.


FFACTOR.PHP	Contains a class of methods that include a functional test for the
		decimal prime split algorithm, as well as the fastest prime factoring
		methods available in this suite.  The fast factoring methods require
		about 2.4 gigabytes of PHP free mem to load the entire prime list.


PRIMES.BIN	A binary file containing the list of all 32-bit primes starting from
		2, stored in an array of 32-bit unsigned integers.  qFactor() builds
		this list as a progressive function of on-going composite factoring.
		This file can grow up to about 600 MB.


MODULO.BIN	A binary file containing modulus counters used for progressively
		calculating primes, as well as a 32-bit TOP_PRIME domain crawl
		iterator.  Its respective file size is 4 greater than PRIMES.BIN.

		Both PRIMES.BIN and MODULO.BIN do not come included in the
		repository, as these files are auto-generated by the prime
		number factory.



+------------+
| FACTOR.PHP |
+------------+


function factor ($n : int) = $factors [] : int;

	A basic implementation of the composite prime factoring algorithm.
	An extra step is added to determine if $n is even and factor it to
	relieve the main loop from supurfluous modulus calculations of even
	numbers greater than 2.


    input:	$n		Number to factor, in the range of 2 ... 2^63 - 1.
				(a proper PHP positive integer)


    output:	$factors []	Array of of prime factorials making up $n in ascending
				order.  Any multiples of the same prime will occur
				contigiously in the list.  If only one element is
				in $factors, then $n is prime.

				If $n is specified to be a non-prime composite or a
				positive number above the 63-bit ceiling, the
				function returns an empty array.



function prime ($n : int) = $yes : int;

	This function uses a basic short-circuit linear not-modulus search algorithm
	to check if $n is a prime or not.  It is an optimized version of factor()
	that skips the factoring and just returns a binary expression.


    input:	$n		Number to factor, in the range of 2 ... 2^63 - 1.
				(a proper PHP positive integer)


    output:	$yes		== 1: $n is a prime value

				== 0: $n is not prime.  If $n is a non-integer or
				contains a value less than 2, the output is always 0.



+-------------+
| QFACTOR.PHP |
+-------------+


function qFactor ($n : int, $find_factors = 1) = $factors [] : int;

	qFactor() is a self-contained prime number factory and prime factoring
	function.  Primarialy it is used to replace factor() in algorithms requiring
	increased factoring performance for handling large numbers more efficiently.

	qFactor() uses a hybrid Sieve of Eratosthenes algorithm to render out a bitmap
	representing a linear slice of the composite prime domain.  The actual prime
	numbers are then extracted at the offset of where any set bits are in the
	bitmap, and stored in PRIMES.BIN (it will be created if not already).

	A secondary file MODULO.BIN is also used to store and maintain the modulus
	counters that are associated with the existing primes and are needed for
	progressive prime production.

	qFactor() finally uses the PRIMES.BIN database to do a not-modulus search for
	factorials of $n, potentially up to the square root of $n.  If the prime
	values are already available in the PRIMES.BIN the production stage of
	qFactor() is skipped entirely.


    input:	$n		Number to factor, in the range of 2 ... 2^63 - 1.
				(a proper PHP positive integer)

				if $n == 9223372036854775783 on call, qPrimes() will
				create a complete PRIMES.BIN file in one session,
				although this can take 20 minutes or more.

		$find_factors	== 1: return factors as an array akin to factor()

				== 0: use a short-circuit factor search and return
				no more than 2 factors if the number is non-prime


    output:	$factors []	Array of of prime factorials making up $n in ascending
				order.  Any multiples of the same prime will occur
				contigiously in the list.  If only one element is
				in $factors, then $n is prime.

				If $n is specified to be a non-prime composite or a
				positive number above the 63-bit ceiling, the
				function returns an empty array.

				If $find_factors is == 0 on call and $n is non-prime,
				this list will only contain 2 elements:
				$factors[0] = the first prime factorial
				$factors[1] = 1
				


function qPrime ($n : int) = yes : int;

	This function behaves identically to prime().  In the implementation, it
	calls qFactor() with $find_factors = 0 to do a short-circuit prime test.
	Refer to primes() for info on the operation of this function.
	


+-------------+
| FFACTOR.PHP |
+-------------+


function get_value ($s) : int;

	Converts a number string containing a K, M, or G metric suffix to the full
	integer value using 2^10, 2^20 or 2^30 scaling respectively.



function get_free_mem () : int;

	Returns the difference between the PHP.INI "memory_limit" value and the
	current memory usage reported by memory_get_usage ().



The Prime class
---------------
Besides containing the main decimal prime split and functional prime split test methods,
the primes class is a high-speed implementation of the common prime factoring
functions using a preloaded prime table in RAM for fast prime factoring.  Because this
class depends on the entire PRIMES.BIN file being loaded into an Spl fixed array, this
is a memory-critical class.  A complete PRIMES.BIN file has 146144319 prime numbers in
it, and PHP stores 17 bytes per Spl array element, so the amount of free PHP script
memory required to use the Prime class is 146144319 * 17 = 2484453423 bytes of RAM
(about 2370 MB of RAM).  This class will check to see if there is enough free memory
available from the system before trying to initialize itself.  You may have to 
increase the memory_limit to 2400M in PHP.INI to take advantage of the fast factoring.



public $type_bitmap : int;

	When Prime is made new, $type_bitmap will be set according to $test_bitmap
	(see below).  If the primes were not allocated due to a shortage of memory,
	bit 2 in $type_bitmap will be cleared to 0 even if set previously.

    BIT 0:	enable		 factor() tests in decimal_split_test()
    BIT 1:	enable		qFactor() tests in decimal_split_test()
    BIT 2:	enable Prime ->  factor() tests in decimal_split_test()

	Other bits are reserved and set to 0.



public function __construct ($test_bitmap) = $error : int;

	This is invoked when creating an object, such as with $p = new Primes.
	It will attempt to allocate the RAM for PRIMES.BIN and will return on error.
	Moreover this function will complete the PRIMES.BIN file if it is not full.

	Typically it takes around 18 seconds to load PRIMES.BIN into the object,
	so keep this in mind when using this class.

	If PRIMES.BIN is non-existant or relatively small it will be created and/or
	expanded to the required size, and this will take about 20 minutes.


    input:	$test_bitmap	When bits 0, 1, or 2 are set the respective factor(),
				qFactor() and fFactor () are invoked in the
				Prime -> decimal_split_test() method when running
				each test.


    output:	$error		== 0 if no error
				== 1 if allocation fails



public function Prime -> factor ($n : int, $find_factors = 1) = factors [] : int;

	This function behaves analogous to factor (); see aforementioned for details.



public function Prime -> test ($n : int) = yes : int;

	This function behaves analogous to prime (); see aforementioned for details.



public function Prime -> indexLookup ($index) = $value : int;

	This function will take a prime index value starting from zero and return the
	prime number in the list @ [$index].  An error is generated if $index is
	specified outside the scope of the prime list.


    input:	$index		Requested prime index, starting from 0


    output:	$value		== -1 if bounds check fails on $index
				>=  2 is returned prime value from specified index



public function Prime -> valueLookup ($value) = $index : int;

	This function does the reverse of Prime->indexLookup(), in that you specify a
	$value and it will return the index to the first prime found equal to or
	greater than $value in the primes list starting from the beginning.  An error
	is generated if $value is specified outside the domain of the prime list.


    input:	$value		Requested value to index into prime table


    output:	$index		== -1 if bounds check fails on $value

				>=  0 index to first prime found equal to
				or greater than $value in the prime list.



public function Prime -> decimal_split ($n : int, $decompose = 0, $method_type = 0) = $factors [] : int;

	Determines if a positive base-10 integer $n (up to 19 digits) contains a list
	of digits composed entirely of left-justified discrete primes numbers or not.
	Applications are seemingly to test programmer wit in a competition for IT
	employment in the mainstream industry, and that's good enough for me.


    input:	$n 		Number to split

		$decompose	== 0: return only primes from a perfect split

				>= 1: return prime splits, as well as the factors
				making up the composite prime that broke the test.
				The decompose mode is mostly implemented for testing.

		$method_type	Specifies the prime function suite to test.
				0: use factor ()
				1: use qFactor()
				2: use Prime->factor()

				NOTE: do not use type 2 if $type_bitmap is < 4.


    output:	$factors []	List of all the prime splits, plus the factors for
				the right-justified composite-prime split if
				$decompose mode = 1.

				If a non-prime split is detected when $decompose = 0,
				or if $n is an invalid composite prime, the array
				will be returned empty.
				


public function Prime -> decimal_split_test ($magnitude = 2, $iterations = 1, $show_proof = 1) = $errors : int;

	A unit test for decimal_prime_split().  A range of random numbers determined
	by $magnitude are generated for exercise on decimal_prime_split().  The
	return factors are compared against the original base 10 string for
	equality.  Even the composite primes are reconstituted to verify against the
	source value.  The proof can be optionally output to the con.  When creating
	a new Prime object, the __constructor parameter $test_bitmap specifies which
	factor algorithms to test.  (bit 0: factor(); bit 1: qFactor(); bit 2:
	Prime->factor()).


    input:	$magnitude	When $iterations > 0: random number test range from
				2 to (1 << $magnitude) - 1.  Valid range is 2 ... 62,
				so only a max. 62-bit prime domain can be tested.

				When $iteations == 0: 63-bit +integer split test value.

		$iterations	count of times to repeat the split test with a new
				random number.  If $iterations is zero, $magnitude
				specifies the number to test the split on.

		$show_proof	== 0: supress con output
				>= 1: dump proof of prime split factoring to con


    output:	$errors		count of all mathematical errors found by mismatched
				factors returned from decimal_prime_split() compared
				against the original numerical parameter, including
				any composite prime regeneration errors.



EOF